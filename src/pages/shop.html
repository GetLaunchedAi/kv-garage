---
layout: "base.html"
description: "Shop KV Garage's hand-picked liquidation pallets, mobile accessories, and tech deals. Wholesale and retail prices for resellers and tech enthusiasts."
metaTitle: "Tech Deals & Liquidation Pallets | KV Garage Shop"
tagTitle: "Shop"
title: "Shop"
preloadImg: "/images/landing.avif"
preloadCSS: "/css/shop.css"
permalink: "shopp/"
eleventyNavigation:
  key: Shop
  order: 200
---

<!-- ============================================ -->
<!--                    LANDING                   -->
<!-- ============================================ -->

<section id="int-hero">
  <h1 id="home-h">Tech Deals & Liquidation Pallets</h1>
  {% image './src/images/landing.avif', 'vinyl floors', '', 'lazy',
  '(max-width: 850px) 850px, 1920px'%}
</section>
<!-- ============================================ -->
<!--                Advanced Filter System        -->
<!-- ============================================ -->
<div class="filter-container">
  <!-- Filter Toggle Button (Mobile) -->
  <button id="filter-toggle" class="filter-toggle" aria-label="Toggle filters">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polygon points="22,3 2,3 10,12.46 10,19 14,21 14,12.46"></polygon>
    </svg>
    <span>Filters</span>
  </button>

  <!-- Filter Sidebar -->
  <aside id="filter-sidebar" class="filter-sidebar">
    <div class="filter-header">
      <h3>Filters</h3>
      <button id="filter-close" class="filter-close" aria-label="Close filters">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
  </div>

    <div class="filter-content">

      <!-- Price Range Filter -->
      <div class="filter-group">
        <div class="filter-group-header" data-toggle="price-options">
          <h4>PRICE</h4>
          <svg class="angle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
          </svg>
        </div>
        <div class="filter-options" id="price-options">
          <div class="price-range">
            <div class="price-inputs">
              <input type="number" id="price-from" placeholder="From" min="0" step="0.01">
              <span class="price-separator">-</span>
              <input type="number" id="price-to" placeholder="To" min="0" step="0.01">
            </div>
          </div>
        </div>
      </div>

      <!-- In Stock Filter -->
      <div class="filter-group">
        <div class="filter-group-header" data-toggle="in-stock-options">
          <h4>IN STOCK</h4>
          <svg class="angle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
          </svg>
        </div>
        <div class="filter-options" id="in-stock-options">
          <div class="toggle-switch">
            <input type="checkbox" id="in-stock-toggle" class="toggle-input">
            <label for="in-stock-toggle" class="toggle-label">
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>


      <!-- Brand Filter -->
      <div class="filter-group">
        <div class="filter-group-header" data-toggle="brand-options">
          <h4>BRAND</h4>
          <svg class="angle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
          </svg>
        </div>
        <div class="filter-options" id="brand-options">
          <div class="checkbox-options">
            <!-- Brands will be populated dynamically -->
          </div>
        </div>
      </div>


      <!-- Category Filter -->
      <div class="filter-group">
        <div class="filter-group-header" data-toggle="category-options">
          <h4>CATEGORY</h4>
          <svg class="angle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6,9 12,15 18,9"></polyline>
          </svg>
        </div>
        <div class="filter-options" id="category-options">
          <div class="checkbox-options">
            <!-- Categories will be populated dynamically -->
          </div>
        </div>
      </div>
    </div>

    <div class="filter-actions">
      <button id="clear-filters" class="clear-filters-btn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"></polygon>
        </svg>
        Clear filters
      </button>
    </div>
  </aside>

  <!-- Filter Overlay (Mobile) -->
  <div id="filter-overlay" class="filter-overlay"></div>

<!-- ============================================ -->
  <!--                Main Content Area             -->
<!-- ============================================ -->
  <div class="main-content">
  <!-- Products Header -->
  <div class="products-header scroll-animate">
    <h2 id="products-title">All Products <span id="products-count">(0)</span></h2>
    <div class="products-controls">
      <button id="hide-filters" class="hide-filters-btn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
          <circle cx="12" cy="12" r="3"></circle>
        </svg>
        Hide filters
      </button>
      <button id="show-filters" class="show-filters-btn" style="display: none;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="22,3 2,3 10,12.46 10,19 14,21 14,12.46"></polygon>
        </svg>
        Show filters
      </button>
      <div class="sort-controls">
        <label for="sort-select">Sort by:</label>
        <select id="sort-select" class="sort-select">
          <option value="default">Default</option>
          <option value="price-low">Price: Low to High</option>
          <option value="price-high">Price: High to Low</option>
          <option value="name-asc">Name: A to Z</option>
          <option value="name-desc">Name: Z to A</option>
        </select>
      </div>
    </div>
  </div>

    <!-- Category Description -->
    <div id="category-description" class="category-description scroll-animate" style="display: none;">
      <div class="category-info">
        <button id="back-to-category" class="back-button" style="display: none;">← Back to Category</button>
        <h3 id="category-title"></h3>
        <p id="category-desc"></p>
        <div id="subcategories" class="subcategories"></div>
      </div>
    </div>

  <!-- Products Grid -->
<section id="catalog" class="grid scroll-animate" data-src="/products.json">
  <!-- Products will be loaded here -->
</section>

  <!-- Pagination -->
  <div id="pagination" class="pagination">
    <button id="prev-page" class="pagination-btn" disabled>
      <span>← Previous</span>
    </button>
    <div id="page-numbers" class="page-numbers">
      <!-- Page numbers will be dynamically generated -->
    </div>
    <button id="next-page" class="pagination-btn">
      <span>Next →</span>
    </button>
  </div>
  </div> <!-- End filter-container -->
</div>

<script>
(function () {
  const root = document.getElementById('catalog');
  const DATA_URL = root.getAttribute('data-src') || '/products.json';

  const IS_DEV = /^phpstack-1518311-5868490\.cloudwaysapps\.com$/.test(location.hostname);

  const safeSlug = s => String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
  const toTitle = s => String(s||'').replace(/[-_]+/g,' ').replace(/\w\S*/g,t=>t[0].toUpperCase()+t.slice(1));

  const productUrl = (p) => {
    const id = p.slug || p.id || safeSlug(p.title || p.name || 'item');
    return IS_DEV ? `/product/?slug=${encodeURIComponent(id)}` : `/products/${encodeURIComponent(id)}/`;
  };

  const esc = s => String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const slug = s => String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
  const money = v => (typeof v === 'number' && !Number.isNaN(v)) ? v.toFixed(2) : (parseFloat(v)||0).toFixed(2);

  // Advanced Filter System
  class AdvancedFilterSystem {
    constructor() {
      this.allProducts = [];
      this.filteredProducts = [];
      this.currentFilters = {
        priceMin: null,
        priceMax: null,
        inStock: false,
        brands: [],
        categories: []
      };
      this.sortBy = 'default';
      this.currentPage = 1;
      this.productsPerPage = 10;
      this.currentCategory = null; // Track current category for back button
      
      this.initializeElements();
      this.bindEvents();
      this.initializeSidebarState();
    }

    initializeSidebarState() {
      // Check if filters should be hidden on desktop
      if (window.innerWidth >= 1024) {
        const filtersHidden = localStorage.getItem('filters-hidden') === 'true';
        if (filtersHidden) {
          this.filterSidebar?.classList.add('hidden');
          this.filterContainer?.classList.add('sidebar-hidden');
          this.hideFiltersBtn.style.display = 'none';
          this.showFiltersBtn.style.display = 'flex';
        } else {
          this.filterSidebar?.classList.remove('hidden');
          this.filterContainer?.classList.remove('sidebar-hidden');
          this.hideFiltersBtn.style.display = 'flex';
          this.showFiltersBtn.style.display = 'none';
        }
      } else {
        // On mobile, ensure buttons are in correct state
        this.hideFiltersBtn.style.display = 'none';
        this.showFiltersBtn.style.display = 'none';
      }
    }

    initializeElements() {
      // Filter elements
      this.filterToggle = document.getElementById('filter-toggle');
      this.filterSidebar = document.getElementById('filter-sidebar');
      this.filterClose = document.getElementById('filter-close');
      this.filterOverlay = document.getElementById('filter-overlay');
      this.clearFiltersBtn = document.getElementById('clear-filters');
      this.filterContainer = document.querySelector('.filter-container');
      
      // Filter inputs
      this.priceFrom = document.getElementById('price-from');
      this.priceTo = document.getElementById('price-to');
      this.inStockToggle = document.getElementById('in-stock-toggle');
      this.brandOptions = document.getElementById('brand-options');
      this.categoryOptions = document.getElementById('category-options');
      
      // Main content
      this.mainContent = document.querySelector('.main-content');
      this.productsTitle = document.getElementById('products-title');
      this.productsCount = document.getElementById('products-count');
      this.sortSelect = document.getElementById('sort-select');
      this.hideFiltersBtn = document.getElementById('hide-filters');
      this.showFiltersBtn = document.getElementById('show-filters');
    }

    bindEvents() {
      // Mobile filter toggle
      this.filterToggle?.addEventListener('click', () => this.toggleSidebar());
      this.filterClose?.addEventListener('click', () => this.closeSidebar());
      this.filterOverlay?.addEventListener('click', () => this.closeSidebar());
      
      
      // Price filter
      this.priceFrom?.addEventListener('input', () => this.updatePriceFilter());
      this.priceTo?.addEventListener('input', () => this.updatePriceFilter());
      
      // In stock filter
      this.inStockToggle?.addEventListener('change', () => this.updateInStockFilter());
      
      // Clear filters
      this.clearFiltersBtn?.addEventListener('click', () => this.clearAllFilters());
      
      // Sort
      this.sortSelect?.addEventListener('change', (e) => this.setSortBy(e.target.value));
      
      // Hide/Show filters (desktop)
      this.hideFiltersBtn?.addEventListener('click', () => this.hideSidebar());
      this.showFiltersBtn?.addEventListener('click', () => this.showSidebar());
      
      // Handle window resize
      window.addEventListener('resize', () => {
        this.initializeSidebarState();
      });
      
      // Handle filter group toggles
      document.querySelectorAll('.filter-group-header[data-toggle]').forEach(header => {
        header.addEventListener('click', () => {
          this.toggleFilterGroup(header);
        });
      });

      // Back to category button
      document.getElementById('back-to-category')?.addEventListener('click', () => {
        if (this.currentCategory) {
          this.showCategoryDescription(this.currentCategory);
        }
      });

      // Pagination events
      document.addEventListener('click', (e) => {
        if (e.target.closest('#prev-page')) {
          e.preventDefault();
          this.prevPage();
        } else if (e.target.closest('#next-page')) {
          e.preventDefault();
          this.nextPage();
        } else if (e.target.closest('.page-number')) {
          e.preventDefault();
          const page = parseInt(e.target.closest('.page-number').dataset.page);
          this.goToPage(page);
        }
      });
    }

    // Sidebar management
    toggleSidebar() {
      this.filterSidebar?.classList.toggle('open');
      this.filterOverlay?.classList.toggle('active');
    }

    toggleFilterGroup(header) {
      const targetId = header.dataset.toggle;
      const options = document.getElementById(targetId);
      
      if (options) {
        const isCollapsed = options.classList.contains('collapsed');
        
        if (isCollapsed) {
          // Expand
          options.classList.remove('collapsed');
          header.classList.remove('collapsed');
        } else {
          // Collapse
          options.classList.add('collapsed');
          header.classList.add('collapsed');
        }
      }
    }

    closeSidebar() {
      this.filterSidebar?.classList.remove('open');
      this.filterOverlay?.classList.remove('active');
    }

    hideSidebar() {
      this.filterSidebar?.classList.remove('open');
      this.filterOverlay?.classList.remove('active');
      
      // On desktop, hide the sidebar by adding a class
      if (window.innerWidth >= 1024) {
        this.filterSidebar?.classList.add('hidden');
        this.filterContainer?.classList.add('sidebar-hidden');
      } else {
        this.mainContent?.classList.remove('with-sidebar');
      }
      
      // Toggle button visibility
      this.hideFiltersBtn.style.display = 'none';
      this.showFiltersBtn.style.display = 'flex';
      
      // Store the preference in localStorage
      localStorage.setItem('filters-hidden', 'true');
    }

    showSidebar() {
      // On desktop, show the sidebar by removing the hidden class
      if (window.innerWidth >= 1024) {
        this.filterSidebar?.classList.remove('hidden');
        this.filterContainer?.classList.remove('sidebar-hidden');
      } else {
        this.mainContent?.classList.add('with-sidebar');
      }
      
      // Toggle button visibility
      this.hideFiltersBtn.style.display = 'flex';
      this.showFiltersBtn.style.display = 'none';
      
      localStorage.setItem('filters-hidden', 'false');
    }

    // Filter methods

    updatePriceFilter() {
      this.currentFilters.priceMin = this.priceFrom?.value ? parseFloat(this.priceFrom.value) : null;
      this.currentFilters.priceMax = this.priceTo?.value ? parseFloat(this.priceTo.value) : null;
      
      // Auto-swap if min > max
      if (this.currentFilters.priceMin !== null && this.currentFilters.priceMax !== null && 
          this.currentFilters.priceMin > this.currentFilters.priceMax) {
        [this.currentFilters.priceMin, this.currentFilters.priceMax] = [this.currentFilters.priceMax, this.currentFilters.priceMin];
        this.priceFrom.value = this.currentFilters.priceMin;
        this.priceTo.value = this.currentFilters.priceMax;
      }
      
      this.applyFilters();
    }

    updateInStockFilter() {
      this.currentFilters.inStock = this.inStockToggle?.checked || false;
      this.applyFilters();
    }


    setSortBy(sortBy) {
      this.sortBy = sortBy;
      this.applyFilters();
    }

    clearAllFilters() {
      this.currentFilters = {
        priceMin: null,
        priceMax: null,
        inStock: false,
        brands: [],
        categories: []
      };
      
      // Reset UI
      this.priceFrom.value = '';
      this.priceTo.value = '';
      this.inStockToggle.checked = false;
      this.sortSelect.value = 'default';
      
      // Clear brand selections
      document.querySelectorAll('.checkbox-option input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
      
      // Hide category description
      this.hideCategoryDescription();
      
      this.applyFilters();
    }

    // Populate filter options
    populateFilterOptions() {
      this.populateBrandOptions();
      this.populateCategoryOptions();
      this.updateCounts();
    }


    populateBrandOptions() {
      const brands = [...new Set(this.allProducts.map(p => p.brand).filter(Boolean))];
      
      const brandCheckboxOptions = this.brandOptions.querySelector('.checkbox-options');
      if (brandCheckboxOptions) {
        brandCheckboxOptions.innerHTML = brands.map(brand => {
          const count = this.allProducts.filter(p => p.brand === brand).length;
          return `
            <label class="checkbox-option">
              <input type="checkbox" data-brand="${brand}">
              <span class="checkmark"></span>
              <span class="checkbox-label">${toTitle(brand)} <span class="count">(${count})</span></span>
            </label>
          `;
        }).join('');

        // Bind brand selection events
        brandCheckboxOptions.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const brand = checkbox.dataset.brand;
            
            if (checkbox.checked) {
              if (!this.currentFilters.brands.includes(brand)) {
                this.currentFilters.brands.push(brand);
              }
            } else {
              this.currentFilters.brands = this.currentFilters.brands.filter(b => b !== brand);
            }
            
            this.applyFilters();
          });
        });
      }
    }

    populateCategoryOptions() {
      // Get categories from products
      const productCategories = [...new Set(this.allProducts.map(p => p.category).filter(Boolean))];
      
      // Get all categories from descriptions (including those with no products)
      const allCategories = Object.keys(this.getCategoryDescriptions());
      
      // Combine and deduplicate categories
      const categories = [...new Set([...productCategories, ...allCategories])];
      
      const categoryCheckboxOptions = this.categoryOptions.querySelector('.checkbox-options');
      if (categoryCheckboxOptions) {
        categoryCheckboxOptions.innerHTML = categories.map(category => {
          const count = this.allProducts.filter(p => p.category === category).length;
          return `
            <label class="checkbox-option">
              <input type="checkbox" data-category="${category}">
              <span class="checkmark"></span>
              <span class="checkbox-label">${toTitle(category)} <span class="count">(${count})</span></span>
            </label>
          `;
        }).join('');

        // Bind category selection events
        categoryCheckboxOptions.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const category = checkbox.dataset.category;
            
            if (checkbox.checked) {
              if (!this.currentFilters.categories.includes(category)) {
                this.currentFilters.categories.push(category);
              }
              // Show category description when category is selected
              this.showCategoryDescription(category);
            } else {
              this.currentFilters.categories = this.currentFilters.categories.filter(c => c !== category);
              // Hide category description if no categories are selected
              if (this.currentFilters.categories.length === 0) {
                this.hideCategoryDescription();
              }
            }
            
            this.applyFilters();
          });
        });
      }
    }

    updateCounts() {
      // No specific counts to update for remaining filters
    }

    // Filtering logic
    applyFilters() {
      this.currentPage = 1; // Reset to first page when filters change
      let filtered = [...this.allProducts];

      // Price filter
      if (this.currentFilters.priceMin !== null) {
        filtered = filtered.filter(p => p.price >= this.currentFilters.priceMin);
      }
      if (this.currentFilters.priceMax !== null) {
        filtered = filtered.filter(p => p.price <= this.currentFilters.priceMax);
      }

      // In stock filter
      if (this.currentFilters.inStock) {
        filtered = filtered.filter(p => p.inStock === true);
      }

      // Brand filter
      if (this.currentFilters.brands.length > 0) {
        filtered = filtered.filter(p => this.currentFilters.brands.includes(p.brand));
      }

      // Category filter
      if (this.currentFilters.categories.length > 0) {
        filtered = filtered.filter(p => this.currentFilters.categories.includes(p.category));
      }

      // Sort products
      this.filteredProducts = this.sortProducts(filtered);
      
      // Render products
      this.renderProducts();
    }

    sortProducts(products) {
      const sorted = [...products];
      
      switch (this.sortBy) {
        case 'price-low':
          return sorted.sort((a, b) => (a.price || 0) - (b.price || 0));
        case 'price-high':
          return sorted.sort((a, b) => (b.price || 0) - (a.price || 0));
        case 'name-asc':
          return sorted.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
        case 'name-desc':
          return sorted.sort((a, b) => (b.title || '').localeCompare(a.title || ''));
        default:
          return sorted;
      }
    }

    renderProducts() {
      if (this.filteredProducts.length > 0) {
        const sortedProducts = this.sortProducts([...this.filteredProducts]);
        const totalPages = Math.ceil(sortedProducts.length / this.productsPerPage);
        
        // Reset to page 1 if current page is beyond available pages
        if (this.currentPage > totalPages) {
          this.currentPage = 1;
        }

        const startIndex = (this.currentPage - 1) * this.productsPerPage;
        const endIndex = startIndex + this.productsPerPage;
        const paginatedProducts = sortedProducts.slice(startIndex, endIndex);

        root.innerHTML = paginatedProducts.map(card).join('');
    } else {
        root.innerHTML = `<p class="muted" style="grid-column:1/-1; text-align: center; padding: 2rem;">No products match your filters.</p>`;
      }
      
      this.updateProductCount();
      this.renderPagination();
    }

    updateProductCount() {
      const count = this.filteredProducts.length;
      this.productsCount.textContent = `(${count})`;
    }

    showCategoryDescription(category) {
      const categoryDesc = document.getElementById('category-description');
      const categoryTitle = document.getElementById('category-title');
      const categoryDescText = document.getElementById('category-desc');
      const subcategories = document.getElementById('subcategories');
      const backButton = document.getElementById('back-to-category');

      if (!categoryDesc || !categoryTitle || !categoryDescText || !subcategories) return;

      // Store current category and hide back button for main category view
      this.currentCategory = category;
      if (backButton) {
        backButton.style.display = 'none';
      }

      // Get category description
      const descriptions = this.getCategoryDescriptions();
      const description = descriptions[category] || '';

      // Get subcategories for this category
      const categorySubcategories = this.allProducts.filter(p => 
        p.category === category && p.isSubcategory
      );

      // Show description if it exists, even for categories with no products
      if (description) {
        categoryTitle.textContent = toTitle(category);
        categoryDescText.innerHTML = description;
        
        // Clear and populate subcategories (only if they exist)
        subcategories.innerHTML = '';
        if (categorySubcategories.length > 0) {
          categorySubcategories.forEach(sub => {
            const subItem = document.createElement('div');
            subItem.className = 'subcategory-item';
            subItem.textContent = sub.title;
            subItem.addEventListener('click', () => {
              // Show subcategory description
              this.showSubcategoryDescription(sub.title);
            });
            subcategories.appendChild(subItem);
          });
        }

        categoryDesc.style.display = 'block';
    } else {
        categoryDesc.style.display = 'none';
      }
    }

    hideCategoryDescription() {
      const categoryDesc = document.getElementById('category-description');
      if (categoryDesc) {
        categoryDesc.style.display = 'none';
      }
    }

    showSubcategoryDescription(subcategoryTitle) {
      const categoryDesc = document.getElementById('category-description');
      const categoryTitle = document.getElementById('category-title');
      const categoryDescText = document.getElementById('category-desc');
      const subcategories = document.getElementById('subcategories');
      const backButton = document.getElementById('back-to-category');

      if (!categoryDesc || !categoryTitle || !categoryDescText || !subcategories) return;

      // Show back button for subcategory view
      if (backButton) {
        backButton.style.display = 'block';
      }

      // Get subcategory description
      const descriptions = this.getSubcategoryDescriptions();
      const description = descriptions[subcategoryTitle] || '';

      if (description) {
        categoryTitle.textContent = subcategoryTitle;
        categoryDescText.innerHTML = description;
        
        // Clear subcategories since we're showing a specific subcategory
        subcategories.innerHTML = '';

        categoryDesc.style.display = 'block';
      }
    }

    getCategoryDescriptions() {
      return {
        'Mobile Accessories': 'Protect and enhance your mobile devices with our selection of cases, screen protectors, and accessories. From iPhone cases with MagSafe compatibility to Android accessories, we have the latest mobile gear at liquidation prices.<br><br><strong>Features:</strong><br>• MagSafe compatible cases<br>• Clear and protective designs<br>• Wireless charging support<br>• Enhanced grip and protection',
        'Cables & Chargers': 'Keep your devices powered and connected with our range of charging cables and accessories. From USB-C to Lightning cables, we have the charging solutions you need at wholesale prices.<br><br><strong>Available Types:</strong><br>• USB-C to USB-A cables<br>• Micro USB cables<br>• Lightning cables<br>• Tangle-free designs',
        'Screen Protectors': 'Protect your device screens with our selection of screen protectors. From privacy filters to tempered glass, we have protection for various device models.<br><br><strong>Protection Types:</strong><br>• Privacy screen protectors<br>• Tempered glass<br>• Clear protectors<br>• Device-specific sizing',
        'Watch Accessories': 'Enhance your smartwatch experience with our collection of watch accessories. From protective bumpers to bands, we have accessories for popular watch models.<br><br><strong>Accessories Include:</strong><br>• Protective bumpers<br>• Watch bands<br>• Screen protectors<br>• Charging accessories',
        'Phone Accessories': 'Complete your phone setup with our range of phone accessories. From PopSockets to stands, we have the accessories to make your phone more functional and stylish.<br><br><strong>Popular Items:</strong><br>• PopSockets grips and stands<br>• Phone stands<br>• Car mounts<br>• Styluses',
        'Wholesale Deals': 'Perfect for resellers and bulk buyers! Our wholesale deals offer significant savings on bulk purchases of verified tech products. These deals are ideal for resellers looking to stock up on inventory.<br><br><strong>Deal Types:</strong><br>• Bulk MacBook deals<br>• Mixed tech pallets<br>• Verified condition items<br>• Reseller-friendly pricing'
      };
    }

    getSubcategoryDescriptions() {
      return {
        // No subcategories for tech products currently
      };
    }

    renderPagination() {
      const paginationContainer = document.getElementById('pagination');
      const pageNumbersContainer = document.getElementById('page-numbers');
      const prevBtn = document.getElementById('prev-page');
      const nextBtn = document.getElementById('next-page');

      if (!paginationContainer || !pageNumbersContainer || !prevBtn || !nextBtn) return;

      const totalPages = Math.ceil(this.filteredProducts.length / this.productsPerPage);
      
      if (totalPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
      }

      paginationContainer.style.display = 'flex';

      // Update prev/next buttons
      prevBtn.disabled = this.currentPage === 1;
      nextBtn.disabled = this.currentPage === totalPages;

      // Generate page numbers
      let pageNumbers = '';
      const maxVisiblePages = 5;
      let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      if (startPage > 1) {
        pageNumbers += `<button class="page-number" data-page="1">1</button>`;
        if (startPage > 2) {
          pageNumbers += `<span class="page-ellipsis">...</span>`;
        }
      }

      for (let i = startPage; i <= endPage; i++) {
        pageNumbers += `<button class="page-number ${i === this.currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
      }

      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          pageNumbers += `<span class="page-ellipsis">...</span>`;
        }
        pageNumbers += `<button class="page-number" data-page="${totalPages}">${totalPages}</button>`;
      }

      pageNumbersContainer.innerHTML = pageNumbers;
    }

    goToPage(page) {
      this.currentPage = page;
      this.renderProducts();
    }

    nextPage() {
      const totalPages = Math.ceil(this.filteredProducts.length / this.productsPerPage);
      if (this.currentPage < totalPages) {
        this.goToPage(this.currentPage + 1);
      }
    }

    prevPage() {
      if (this.currentPage > 1) {
        this.goToPage(this.currentPage - 1);
      }
    }

    async loadProducts() {
    try {
      const res = await fetch(`${DATA_URL}${DATA_URL.includes('?') ? '&' : '?'}cb=${Date.now()}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
        this.allProducts = Array.isArray(data) ? data : (Array.isArray(data.products) ? data.products : []);
        
        this.populateFilterOptions();
        this.applyFilters();
    } catch (err) {
      console.error('Failed to load products:', err);
      root.innerHTML = `<p class="muted" style="grid-column:1/-1">Failed to load products.</p>`;
    }
    }
  }

  // Product card function
  function card(p) {
    const href = productUrl(p);
    const img = p.image || '/images/placeholder.jpg';
    const title = esc(p.title || p.name || 'Untitled');
    const price = p.price ? money(p.price) : '0.00';
    const currency = p.currency || 'USD';
    const isOutOfStock = p.price === 0 || p.inStock === false;
    const status = p.status || '';
    const quantity = p.quantity || '';
    
    // Create status badge if status exists
    const statusBadge = status ? `<span class="status-badge status-${status.toLowerCase().replace(/\s+/g, '-')}">${status}</span>` : '';
    
    // Format price display for wholesale deals
    let priceDisplay = '';
    if (isOutOfStock) {
      priceDisplay = 'Out of Stock';
    } else if (quantity && status === 'Wholesale Deal') {
      priceDisplay = `$${price} ${currency} (${quantity})`;
    } else {
      priceDisplay = `$${price} ${currency}`;
    }
    
    return `<article class="card ${isOutOfStock ? 'out-of-stock' : ''}">
        <a href="${esc(href)}" class="card__link">
          <picture class="card__img">
            <img src="${esc(img)}" alt="${esc(title)}" loading="lazy" decoding="async">
            ${statusBadge}
          </picture>
        </a>
        <div class="card__content">
          <h3 class="card__title">
            <a href="${esc(href)}" title="${esc(title)}">${title}</a>
          </h3>
          <p class="card__price">${priceDisplay}</p>
          ${p.description ? `<p class="card__description">${esc(p.description)}</p>` : ''}
        </div>
        <a class="add-to-cart ${isOutOfStock ? 'disabled' : ''}" href="${esc(href)}">${isOutOfStock ? 'Out of Stock' : 'View Details'}</a>
      </article>`;
  }

  // Initialize the advanced filter system
  const filterSystem = new AdvancedFilterSystem();
  
  // Load products into the advanced filter system
  filterSystem.loadProducts();
})();

// Scroll Animations Script
document.addEventListener('DOMContentLoaded', function() {
  // Create intersection observer
  const observerOptions = {
    threshold: 0.1, // Trigger when 10% of element is visible
    rootMargin: '0px 0px -50px 0px' // Start animation slightly before element is fully visible
  };
  
  const observer = new IntersectionObserver(function(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('animate-in');
        // Stop observing once animated to improve performance
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);
  
  // Observe all elements with scroll animation classes
  const animatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-left, .scroll-animate-right, .scroll-animate-scale');
  animatedElements.forEach(element => {
    observer.observe(element);
  });
});
</script>